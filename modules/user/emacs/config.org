#+TITLE: Nilso's GNU Emacs Config
#+AUTHOR: Nilso Junior
#+DESCRIPTION: Nilso's Emacs config

* Early-Init
#+begin_src emacs-lisp :tangle early-init.el
  (menu-bar-mode -1)
  (tool-bar-mode -1)
  (scroll-bar-mode -1)

  (setq initial-buffer-choice nil
        inhibit-x-resources t
        frame-inhibit-implied-resize t)
#+end_src

Disable startup message
#+begin_src emacs-lisp :tangle early-init.el
  (defun display-startup-echo-area-message ()
    (message ""))
#+end_src

* Evil Mode
** Before Evil
#+begin_src emacs-lisp
  (setq-default indent-tabs-mode nil
                tab-width 4)

  (setq evil-want-C-u-scroll t
        evil-want-C-u-delete t
        evil-want-Y-yank-to-eol t
        evil-want-keybinding nil
        select-enable-clipboard nil
        evil-shift-width 4
        evil-insert-state-cursor '(box))
#+end_src

*** Undo
#+begin_src emacs-lisp
  (setq evil-undo-system 'undo-fu)
  (undo-fu-session-global-mode)
#+end_src

*** Splits
#+begin_src emacs-lisp
  (setq evil-vsplit-window-right t
        evil-split-window-below t)
#+end_src

** Load Evil
#+begin_src emacs-lisp
  (require 'evil)
  (evil-mode 1)

  (setq evil-collection-setup-minibuffer t)
  (require 'evil-collection)
  (evil-collection-init)

  (require 'evil-commentary)
  (evil-commentary-mode 1)
#+end_src

*** Keybindings

These remaps make the cursor stay centered in the screen while navigating
#+begin_src emacs-lisp
  (defun nj/scroll-down ()
    (interactive)
    (evil-scroll-down nil)
    (evil-scroll-line-to-center nil))

  (defun nj/scroll-up ()
    (interactive)
    (evil-scroll-up nil)
    (evil-scroll-line-to-center nil))

  (defun nj/search-next ()
    (interactive)
    (evil-search-next)
    (evil-scroll-line-to-center nil))

  (defun nj/search-previous ()
    (interactive)
    (evil-search-previous)
    (evil-scroll-line-to-center nil))

  (defun nj/up ()
    (interactive)
    (call-interactively 'evil-previous-line)
    (evil-scroll-line-to-center nil))

  (defun nj/down ()
    (interactive)
    (call-interactively 'evil-next-line)
    (evil-scroll-line-to-center nil))

  (defun nj/insert-blank-line-above (n)
    (interactive "p")
    (save-excursion
      (beginning-of-line)
      (open-line n))
    (when (bolp) (forward-char n)))

  (defun nj/insert-blank-line-below (n)
    (interactive "p")
    (save-excursion
      (end-of-line)
      (open-line n)))

  (evil-define-key 'normal global-map
    (kbd "C-u") 'nj/scroll-up
    (kbd "C-d") 'nj/scroll-down
    (kbd "k") 'nj/up
    (kbd "j") 'nj/down
    (kbd "n") 'nj/search-next
    (kbd "N") 'nj/search-previous
    (kbd "C-p") 'universal-argument
    (kbd "C-a") 'nj/insert-blank-line-below
    (kbd "C-S-a") 'nj/insert-blank-line-above
    (kbd "C-k") 'previous-error
    (kbd "C-j") 'next-error)

  (evil-define-key 'insert global-map (kbd "C-c") 'evil-normal-state)
#+end_src

Stay in visual mode while indenting
#+begin_src emacs-lisp
  (defun nj/indent-right ()
    (interactive)
    (evil-shift-right (region-beginning) (region-end))
    (evil-normal-state)
    (evil-visual-restore))

  (defun nj/indent-left ()
    (interactive)
    (evil-shift-left (region-beginning) (region-end))
    (evil-normal-state)
    (evil-visual-restore))

  (define-key evil-visual-state-map (kbd ">") 'nj/indent-right)
  (define-key evil-visual-state-map (kbd "<") 'nj/indent-left)
#+end_src

** Yank
Highlight text when yanking
#+begin_src emacs-lisp
  (defun highlight-on-yank (orig-fn beg end &rest args)
    (apply orig-fn beg end args)
    (let ((ov (make-overlay beg end)))
      (overlay-put ov 'face 'show-paren-mismatch)
      (run-with-timer 0.040 nil 'delete-overlay ov)))

  (advice-add 'evil-yank :around #'highlight-on-yank)
#+end_src

* Visuals
#+begin_src emacs-lisp
  (blink-cursor-mode 0)
  (set-fringe-mode 0)

  (setq display-line-numbers-type 'relative)
  (global-display-line-numbers-mode 1)
  (setq-default truncate-lines t)
#+end_src

Disable line wrapping
#+begin_src emacs-lisp
  (global-visual-line-mode 0)
#+end_src

** Face Attributes
#+begin_src emacs-lisp
  (defvar nj/accent 'minibuffer-prompt)

  (set-face-attribute 'mode-line nil
                      :inherit 'mode-line
                      :foreground 'unspecified)
  ;; :background "#131520")

  (set-face-attribute 'mode-line-inactive nil
                      :inherit 'mode-line
                      :background 'unspecified)

  (set-face-attribute 'line-number-current-line nil
                      :inherit nj/accent
                      :background 'unspecified)

  (set-cursor-color (face-foreground nj/accent))

  (set-face-attribute 'font-lock-variable-name-face nil
                      :foreground nil)

  (set-face-attribute 'font-lock-function-name-face nil
                      :foreground (face-attribute 'font-lock-warning-face :foreground))

  (set-face-attribute 'show-paren-match nil
                      :background (face-foreground 'error nil 'default)
                      :foreground (face-foreground 'default))

  (defun nj/inherit-background (faces)
    (dolist (face faces)
      (set-face-attribute face nil
                          :inherit 'default
                          :background 'unspecified)))

  (nj/inherit-background
   '(fringe
     ;; tooltip
     line-number))
  ;; line-number-current-line
  ;; mode-line-inactive
#+end_src

Add the accent colour for symbols
#+begin_src emacs-lisp
  (defun nj/colours ()
    (unless (derived-mode-p 'help-mode 'special-mode)
      (font-lock-add-keywords nil
                              '(("->" . nj/accent)
                                ("<-" . nj/accent)
                                ("=>" . nj/accent)
                                ("[]{}()!@#$%^&*+=|\\~`?/;:,.<>'\"\[]" . nj/accent))
                              'append)
      (when (derived-mode-p 'org-mode)
        (font-lock-flush))))

  (add-hook 'after-change-major-mode-hook 'nj/colours)
#+end_src

Make the default font bold
#+begin_src emacs-lisp
  (set-face-attribute 'default nil :weight 'bold)
#+end_src

** Mode Line
#+begin_src emacs-lisp
  (defun nj/buffer-name ()
    (if (buffer-file-name)
        (if-let* ((p (project-current))
  				(p-root (project-root p))
  				(p-name (project-name p)))
  		  ;; (format "%s/%s" p-name
  		  (format "%s"
  				  (file-relative-name (buffer-file-name) p-root))
  		(abbreviate-file-name (buffer-file-name)))
      (buffer-name)))

  (setq-default mode-line-format
  			  '("%e"
  				(" ")
  				(:propertize
  				 (:eval (nj/buffer-name))
  				 )))
#+end_src

* Keybindings
Maybe I want buffer navigation keybinds?
#+begin_src emacs-lisp
  (require 'general)
  (general-evil-setup)

  (general-create-definer nj/leader-keys
    :states '(normal insert visual emacs)
    :keymaps 'override
    :prefix "SPC"
    :global-prefix "C-SPC")

  (defun nj/project-switch-find-file ()
    "Switch projects and instantly look for a file."
    (interactive)
    (let* ((project (project-prompt-project-dir))
           (default-directory project))
      (project-find-file)))

  (defun nj/open-remote ()
    "Open remote repository in the browser."
    (interactive)
    (if (project-current)
        (let ((url (string-trim (shell-command-to-string "git remote get-url origin"))))
          (if (string-match-p "github\\.com" url)
              (browse-url (string-replace "git@github.com:" "https://github.com/" url))
            (message "ERROR: The repository: %s is not hosted on GitHub." url)))
      (message "ERROR: Not a git repository.")))

  (nj/leader-keys
    "y" '((lambda () (interactive) (evil-use-register ?+) (call-interactively 'evil-yank)) :wk "Yank to system clipboard")
    "Y" '((lambda () (interactive) (evil-use-register ?+) (call-interactively 'evil-yank-line)) :wk "Yank to system clipboard")
    "d" '(:ignore t :wk "Project")
    "df" '(project-find-file :wk "Find File")
    "dp" '(nj/project-switch-find-file :wk "Switch Projects")
    "dk" '(project-compile :wk "Compile")
    "dj" '(project-recompile :wk "Recompile")
    "db" '(project-switch-to-buffer :wk "Switch Buffers")
    "ds" '(project-shell-command :wk "Shell Command")
    "da" '(project-async-shell-command :wk "Async Shell Command")
    "f"  '(:ignore t :wk "Find")
    "fj" '(switch-to-buffer :wk "Switch Buffers")
    "fk" '(recentf :wk "Recent File")
    "fi" '(imenu :wk "Imenu")
    "sd" '(shell-command :wk "Shell Command")
    "sf" '(async-shell-command :wk "Async Shell Command")
    "cj" '(recompile :wk "Recompile")
    "ck" '(compile :wk "Compile")
    "gh" '(nj/open-remote :wk "Open remote repo in browser"))

  (defun nj/paste-from-system ()
    (interactive)
    (evil-paste-from-register ?+))

  (keymap-set global-map "C-S-V" 'nj/paste-from-system)
#+end_src

* WHICH-KEY
#+begin_src emacs-lisp
  (require 'which-key)
  (which-key-mode 1)
#+end_src

* ORG MODE
#+begin_src emacs-lisp
  (setq org-modern-star 'replace
        org-ellipsis " â–¾")
  ;; org-hide-emphasis-markers t
  (with-eval-after-load 'org (global-org-modern-mode))
  (require 'org-tempo)
#+end_src

Make ellipsis use the same color as the header
#+begin_src emacs-lisp
  (set-face-attribute 'org-ellipsis nil
                      :foreground 'unspecified)
#+end_src

* Defaults
#+begin_src emacs-lisp
  (make-directory (expand-file-name "backup/" user-emacs-directory) t)
  (make-directory (expand-file-name "auto-save/" user-emacs-directory) t)
  (make-directory (expand-file-name "lock/" user-emacs-directory) t)

  (setq backup-directory-alist
        `(("." . ,(expand-file-name "backup/" user-emacs-directory)))
        auto-save-file-name-transforms
        `((".*" ,(expand-file-name "auto-save/" user-emacs-directory) t))
        lock-file-name-transforms
        `((".*" ,(expand-file-name "lock/" user-emacs-directory) t))
        use-short-answers t)

  (setq compilation-scroll-output t)

  (defun nj/format-buffer ()
    (when-let* ((project (project-current))
                (p-root (project-root project)))
      (let ((files (mapcar (lambda (f) (expand-file-name f p-root))
                           '(".clang-format"))))
        (unless (seq-some 'file-exists-p files)
          (indent-region (point-min) (point-max)))))
    (delete-trailing-whitespace))

  (add-hook 'before-save-hook 'nj/format-buffer)

  (global-auto-revert-mode)

  ;; Source - https://stackoverflow.com/a/8371037
  ;; Posted by angus
  ;; Retrieved 2026-01-31, License - CC BY-SA 3.0
  (set-display-table-slot standard-display-table 0 ?\ )
#+end_src

Last compile command will be the default
#+begin_src emacs-lisp
  (setq-default compile-command '(car compile-history))
#+end_src

* Dired
#+begin_src emacs-lisp
  ;; (setq dired-recursive-deletes 'always
  ;; 	dired-recursive-copies 'always)
  (setq dired-listing-switches "-lahv --group-directories-first"
        dired-kill-when-opening-new-dired-buffer t
        dired-auto-revert-buffer t)

  (require 'diredfl)
  (diredfl-global-mode 1)
  (set-face-attribute 'diredfl-date-time nil :weight 'unspecified :inherit 'default)
#+end_src

* Completions
This will go to the next line or previous if fido-vertica-mode is enabled. Otherwise it will navigate history.
#+begin_src emacs-lisp
  (savehist-mode 1)
  (recentf-mode 1)

  (fido-vertical-mode)
  (evil-define-key 'insert icomplete-fido-mode-map
    (kbd "C-k") 'icomplete-backward-completions
    (kbd "C-j") 'icomplete-forward-completions)

  (evil-define-key 'insert minibuffer-local-map
    (kbd "C-k") 'previous-line-or-history-element
    (kbd "C-j") 'next-line-or-history-element)
#+end_src

* Ansi Colours
Using xterm instead
#+begin_src emacs-lisp
  ;; (require 'ansi-color)

  ;; (add-hook 'compilation-filter-hook 'ansi-color-compilation-filter)
  ;; (setq ansi-color-for-compilation-mode t)

  ;; (add-hook 'comint-output-filter-functions 'ansi-color-process-output)
  ;; (setq ansi-color-for-comint-mode t)
#+end_src

* Buffer Completions
#+begin_src emacs-lisp
  (require 'corfu)
  (global-corfu-mode)
  (corfu-history-mode)
  (corfu-popupinfo-mode)

  (require 'cape)
  (add-hook 'completion-at-point-functions #'cape-dabbrev)
  (add-hook 'completion-at-point-functions #'cape-file)
  (add-hook 'completion-at-point-functions #'cape-elisp-block)

  (setq corfu-auto-delay 0.15
        corfu-echo-delay 0.15
        corfu-popupinfo-direction '(right)
        corfu-border-width 0
        ;; corfu-auto t
        text-mode-ispell-word-completion nil) ;; Not sure

  (keymap-unset corfu-map "RET")
  (keymap-set corfu-map "C-<return>" 'corfu-insert)
  (evil-collection-define-key 'insert 'corfu-map
    (kbd "C-u") nil
    (kbd "C-d") 'corfu-popupinfo-toggle
    (kbd "C-n") 'corfu-popupinfo-scroll-up
    (kbd "C-p") 'corfu-popupinfo-scroll-down)
#+end_src

Hide commands in M-x which do not apply to the current mode.
Corfu commands are hidden, since they are not used via M-x.
This setting is useful beyond Corfu.
#+begin_src emacs-lisp
  (setq read-extended-command-predicate #'command-completion-default-include-p)
#+end_src

Start completion after 2 characters
#+begin_src emacs-lisp
  (setq corfu-auto-prefix 2)
#+end_src

Disable scroll bar
#+begin_src emacs-lisp
  (setq corfu-bar-width 0)
#+end_src

We use manual toggle
#+begin_src emacs-lisp
  (setq corfu-popupinfo-delay nil)
#+end_src

Just TAB will trigger completion instead of M-TAB
#+begin_src emacs-lisp
  (setq tab-always-indent 'complete)
#+end_src

* Treesitter
For some reason I have to require this so things that use `rust-mode` work.
Otherwise I can't jump between erros in the compilation buffer.
Maybe I should just use `rust-mode` with `rust-mode-treesitter-derive`?
#+begin_src emacs-lisp
  (require 'rust-mode)
#+end_src

** Modes
#+begin_src emacs-lisp
  ;; (setq treesit-font-lock-level 3
  ;;       nix-ts-mode-indent-offset 4
  ;;       rust-ts-mode-indent-offset 4
  ;;       lua-ts-mode-indent-offset 4
  ;;       just-ts-mode-indent-offset 4)

  ;; (setq major-mode-remap-alist
  ;;       '((nix-mode . nix-ts-mode)
  ;; (rust-mode . rust-ts-mode)
  ;; (lua-mode . lua-ts-mode)
  ;; (just-mode . just-ts-mode)
  ;; (markdown-mode . markdown-ts-mode)))

  (defun nj/set-indentation (modes)
    (dolist (mode modes)
      (add-hook mode (lambda () (setq tab-width 4)))))

  (nj/set-indentation '(nix-mode-hook
                        rust-mode-hook
                        lua-mode-hook
                        just-mode-hook))
#+end_src

* Language Servers
#+begin_src emacs-lisp
  (require 'eglot)
  (setq eglot-ignored-server-capabilities '(:inlayHintProvider))
  (add-hook 'eglot--managed-mode-hook (lambda () (flymake-mode -1)))

  (add-hook 'rust-ts-mode-hook 'eglot-ensure)
#+end_src


* Expand
#+begin_src emacs-lisp
  (defvar nj/expand-state nil)

  (defun nj/expand ()
    (interactive)
    (call-interactively nj/expand-state))

  (evil-define-key 'visual global-map (kbd "K") 'nj/expand)

  (defun nj/expand-advice-add (funcs)
    (dolist (f funcs)
      (evil--advice-add f :after
                        `(lambda (&rest _args)
                           (setq nj/expand-state ',f)))))

  (nj/expand-advice-add '(evil-a-paren
                          evil-inner-paren

                          evil-a-bracket
                          evil-inner-bracket

                          evil-a-curly
                          evil-inner-curly

                          evil-a-back-quote
                          evil-inner-back-quote

                          ;; evil-a-single-quote
                          ;; evil-inner-quote

                          ;; evil-a-double-quote
                          ;; evil-inner-double-quote

                          evil-a-paragraph
                          evil-inner-paragraph

                          evil-a-tag
                          evil-inner-tag))
#+end_src

* XTERM
** Comint
Also set TERM accordingly (xterm-256color) in the shell itself
#+begin_src emacs-lisp
  (require 'xterm-color)
  (add-hook 'shell-mode-hook
            (lambda ()
              ;; Disable font-locking in this buffer to improve performance
              (font-lock-mode -1)
              ;; Prevent font-locking from being re-enabled in this buffer
              (make-local-variable 'font-lock-function)
              (setq font-lock-function (lambda (_) nil))
              ;; Replace ansi-color-process-output with xterm-color-filter
              (make-local-variable 'comint-output-filter-functions)
              (remove-hook 'comint-output-filter-functions 'ansi-color-process-output t)
              (add-hook 'comint-preoutput-filter-functions 'xterm-color-filter nil t)))
#+end_src

** Eshell
#+begin_src emacs-lisp
  (require 'eshell) ; or use with-eval-after-load

  (add-hook 'eshell-before-prompt-hook
            (lambda ()
              (setq xterm-color-preserve-properties t)))

  (add-to-list 'eshell-preoutput-filter-functions 'xterm-color-filter)
  (setq eshell-output-filter-functions (remove 'eshell-handle-ansi-color eshell-output-filter-functions))
  (setenv "TERM" "xterm-256color")
#+end_src

** Compilation
#+begin_src emacs-lisp
  (setq compilation-environment '("TERM=xterm-256color"))

  (define-advice compilation-filter (:around (f proc string) xterm-color)
    (funcall f proc (xterm-color-filter string)))
#+end_src

* Magit
#+begin_src emacs-lisp
  (require 'magit)
#+end_src

* Vterm
#+begin_src emacs-lisp
  (require 'vterm)
  (evil-define-key 'insert vterm-mode-map (kbd "C-c") 'vterm--self-insert)
  (add-hook 'vterm-mode-hook (lambda () (display-line-numbers-mode 0)))

  (defun nj/toggle-vterm-in-buffer (n)
    (interactive "P")
    (if (eq major-mode 'vterm-mode)
        (evil-buffer nil)
      (vterm n)))

  (defun nj/toggle-vterm (n)
    (interactive "P")
    (if-let* ((project (project-current))
              (p-root (project-root project)))
        (if (eq major-mode 'vterm-mode)
            (evil-buffer nil)
          (let ((default-directory p-root)
                (vterm-buffer-name (concat "*vterm " (project-name p-root) "*")))
            (if (get-buffer vterm-buffer-name)
                (switch-to-buffer vterm-buffer-name)
              (vterm vterm-buffer-name))))
      (nj/toggle-vterm-in-buffer n)))

  (nj/leader-keys "te" '(nj/toggle-vterm :wk "Toggle vterm"))
  (nj/leader-keys "td" '(nj/toggle-vterm-in-buffer :wk "Toggle vterm"))
#+end_src
